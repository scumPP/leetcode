# 整数反转

## 题目

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转

**注意**:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

示例：

```Python
1.
输入：123
输出：321
2.
输入：-123
输出：-321
```

### 方法一

这道题正常解题思路不难，就是将输入的整数，转换成int，记录下正负，在进行字符串逆遍历，最后判断下是否超出范围即可，完整代码为：

```python
def reverse(x):
    s=str(x)
    re=''
    n=len(s)
    if s[0]!='-':
        for i in range(n-1,-1,-1):
            re+=s[i]
    else:
        for i in range(n-1,0,-1):
            re+=s[i]
        re=s[0]+re
    re=int(re)
    if ((-2)**31) <= re and re <= (2**31-1):
        return re
    else:
        return 0
```

这样写的时间复杂度和空间复杂度没有什么优势，可以说是没有任何亮点。那么来看下一个方法：

### 方法二

因为我们要逆序输出，那么对于整数来说，我们可以先从个位数开始一个个地将数字取出再整合一起，就像下面这样：

```python
res=0
while num!=0:
    res=res*10+num%10
    num/=10
```

代码中，res表示已经取出的数字，num代表当前需要反转的数字，因此num%10代表取出num的最后一个数字，num/10代表取出除了最后一位数字的其他数字，举个例子：

```python
num=123
num%10=3
num/10=12
```

由于有正负之分，我们在进行反转时可以先取绝对值，python中用abs()这个函数，在判断范围时，我们可以直接判断，就像第一种方法那样：

```python
if ((-2)**31) <= re and re <= (2**31-1):
    return re
else:
    return 0
```

也可以用移位算法来进行判断：

```python
boundary=1<<31 if num<0 else (1<<31)-1
```

注意此时的边界条件是绝对值，所以这样写

**解释位运算符**<<和>>：

+ a<<2
左移运算符：运算数的各二进制位全部向左移动n位，n由运算符右边的数字决定，高位丢弃，低位补0，“a<<2”就是数字a的所有二进制位向左移2位

```python
例如：
a=10  #int 十进制
a_binary=1010 #二进制
print(a<<2)
输出：
40
```

40的二进制为101000

+ a>>2
右移运算符：运算数的各二进制位全部向右移动n位，n取决于运算符右边的数字，移位后左边补0

```python
例如：
a=10  #int 十进制
a_binary=1010 #二进制
print(a>>2)
输出：
2
```

2的二进制为10

这个方法的完整代码就是：

```python
def reverse_optimize(num):
    y=abs(num)
    res=0
    boundary=(1<<31)-1 if num>0 else 1<<31
    while y!=0:
        res=res*10+y%10
        if res>boundary:
            return 0
        y/=10
```
