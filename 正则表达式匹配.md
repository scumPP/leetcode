# 正则表达式匹配

## 题目

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

+ '.' 匹配任意单个字符
+ '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖**整个**字符串s的，而不是部分字符串。

**说明**:

+ s 可能为空，且只包含从 a-z 的小写字母。
+ p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例：

```python
1.输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
######################################################
2.输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
######################################################
3.输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

## 思想

这道题是真的难搞，情况有点复杂，看了好久的解析，现在赶紧记录一波，以此加深印象，还有就是更进一步理解动态规划的思想。

此题解题方法为动态规划，那么我们就来看下动态规划的最优子结构是什么？状态转移方程又是什么？

首先定义最优子结构: $dp[i][j]$ ,意思是字符串 $s$ 的前 $i$ 个字符和字符串 $p$ 的前 $j$ 个字符是否匹配，即 $dp[i][j]$ 是一个$bool$值,匹配为1，不匹配为0。

那么，我们的状态转移方程的思想是什么呢？如果我们遍历到了当前的$dp[i][j]$ ,也就是说 $dp[i][j]$ 之前的匹配情况我们都是知道的，因此我们根据当前情况去找已知的匹配情况的话，我们就可以得出结果了。

在已知 $dp[i][j]$ 之前所有匹配情况并且 $s$ 和 $p$ 都不为空的条件下，我们判断当前情况的话，首先分为三种：

1. $s[i]==p[j]$ ,当前需要判断的两个字符都是字母且相等，那么我们就只需看他们的前一个匹配情况就好啦，即 $dp[i][j]=dp[i-1][j-1]$

2. $p[j]=='.' $ ,即当前的 $p$ 字符是特殊字符$'.'$ , $'.'$ 的含义是匹配任意单个字符，是万能字符，因此等同于第一个条件，于是状态转移方程和第一个一样，即 $dp[i][j]=dp[i-1][j-1]$

3. $p[j]=='*' $ ，即当前 $p$ 字符是特殊字符 $'*'$，由于 $'*'$ 这个符号的特殊含义，因此我们需要根据 $'*'$ 前面的字符做判断，如下：
(1) 若 $s[i]!=p[j-1]$ ，即$'aa,ab*'$ 的情况，那么我们要根据$'*'$前面的倒数第二个字符进行判断，即 $dp[i][j]=dp[i][j-2]$
(2) 若 $s[i]==p[j-1]$ 或者 $p[j-1]=='.'$ 时, 为什么这两个一起讨论，因为 $'.'$ 是万能字符，就相当于当前要匹配的两个字符是相等的情况。这种情况下怎么操作呢？

